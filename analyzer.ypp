%{
    #include <string>
    #include "types.hpp"
    #include "debug.hpp"
    #include "markers.hpp"
    #include "hw3_output.hpp"
    #include "symbol_table_manager.hpp"
    #include "actions.hpp"
    #include "validations.hpp"
    using namespace output;
    using namespace actions;
    using namespace validations;
    extern int yyerror(const char *s);
    _T_Type::Type current_func_ret_type;
    bool in_if;
    bool in_else;
    bool in_while;
    Store store = Store::instance();
%}
%union {
struct _T_Exp*              T_Exp;
struct _T_Number*           T_Number;
struct _T_Declaration*      T_Declaration;
struct _T_Assignment*       T_Assignment;
struct _T_LateAssignment*   T_LateAssignment;
struct _T_FunctionCall*     T_FunctionCall;
struct _T_Return*           T_Return;
struct _T_If_pattern*       T_If_pattern;
struct _T_While*            T_While;
struct _T_Statements*       T_Statements;
struct _T_Statement*        T_Statement;
struct _T_Not*              T_Not;
struct _T_If*               T_If;
struct _T_Else*             T_Else;
struct _T_Id*               T_Id;
struct _T_String*           T_String;
struct _T_Cast*             T_Cast;
struct _T_Void*             T_Void;
struct _T_Bool*             T_Bool;
struct _T_RetType*          T_RetType;
struct _T_Program*          T_Program;
struct _T_Funcs*            T_Funcs;
struct _T_FuncDecl*         T_FuncDecl;
struct _T_Formals*          T_Formals;
struct _T_FormalsList*      T_FormalsList;
struct _T_FormalDecl*       T_FormalDecl;
struct _T_ExpList*          T_ExpList;
struct _T_Type*             T_Type;
struct _T_Binop*            T_Binop;
struct _T_Trinari*          T_Trinari;
struct _T_Call*             T_Call;
struct _T_CallExp*          T_CallExp;
}
%left OR
%left AND
%left GT
%left GE
%left LT
%left LE
%left NE
%left EQ
%left ADD
%left SUB
%left MULT
%left DIV
%left NOT
%left RPAREN
%left LPAREN
%left LBRACE
%left RBRACE
%right ASSIGN
%right IF
%right ELSE
%token RETURN
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token B
%token NUM
%token ID
%token STRING
%token VOID
%token INT
%token BYTE
%token BOOL
%token FALSE
%token TRUE
%type <T_Type> void
%type <T_Type> int
%type <T_Type> byte
%type <T_Type> bool
%type <T_Bool> false
%type <T_Bool> true
%type <T_String> string
%type <T_Id> id
%type <T_Id> fid
%type <T_Program> program
%type <T_Funcs> funcs
%type <T_FuncDecl> funcDecl
%type <T_RetType> retType
%type <T_Formals> formals
%type <T_FormalsList> formalsList
%type <T_FormalDecl> formalDecl
%type <T_Statements> statements
%type <T_Statement> statement
%type <T_Statement> if_pattern
%type <T_ExpList> expList
%type <T_Type> type
%type <T_Exp> exp
%type <T_Exp> bool_exp
%type <T_Number> number
%type <T_Binop> binop
%type <T_CallExp> call
%%
program:
initMarker funcs
{debug(); $$ = new _T_Program($2);  }
initMarker: {debug(); InitMarker(); }
;
funcs:
epsilon
{debug(); $$ = new _T_Funcs(); }
| funcDecl funcs
{debug();
    $2->func_list.push_back($1);
    $$ = $2;
}
;

funcDecl:
retType fid LPAREN formals RPAREN LBRACE statements RBRACE

{debug();
    $2->type = $1->type;
    auto func = new _T_FuncDecl($2, $4, $7);
    end_function(&store, func);
    $$ = func;
}
;

fid:
id
{debug();
    if(is_func_declared(&store, $1)) {debug();
        errorDef(yylineno, $1->id);
        exit(1);
    }
    declare_func(&store, $1);
    $$ = $1;
}
;

retType:
type
{debug();
    begin_function(&store, $1->typeCase);
    auto ret     = new _T_RetType($1);
    $$ = ret;
}
| void
{debug();
    begin_function(&store, _T_Type::_VOID_);
    $$ = new _T_RetType(_T_Type::_VOID_);;
}
;
formals:
epsilon
{debug(); $$ =  new _T_Formals(); }
| formalsList
{debug();
    insert_function_params(&store, $1);
    $$ = new _T_Formals($1);
}
;
formalsList:
formalDecl
{debug(); $$ =  new _T_FormalsList($1); }
| formalDecl COMMA formalsList
{debug();
    if(is_formal_declared($3->formal_list, $1->id)){debug();
        errorDef(yylineno, $1->id->id);
        exit(1);
    }
    $3->formal_list.insert($3->formal_list.begin(), $1);
    $$ = $3;
}
;

formalDecl:
type id
{debug();
    if(is_id_declared(&store, $2)) {debug();
        errorDef(yylineno, $2->id);
        exit(1);
    }
    $2->type = $1;
    $$ = new _T_FormalDecl($2);
}
;

statements:
statement
{debug();
    auto stmnts = new _T_Statements($1);
    $$ = stmnts;
}
| statements statement
{debug();
    $1->statement_list.push_back($2);
    $$ = $1;
}
;

statement:
lbrace statements rbrace
{debug(); $$ = $2; }
| type id SC
{debug();
    if(is_id_declared(&store, $2)) {debug();
        errorDef(yylineno, $2->id);
        exit(1);
    }
    $2->type = $1;
    insert_id(&store, $2);
    auto decl = new _T_Declaration($1, $2);
    $$ = decl;

}
| type id ASSIGN exp SC
{debug();
    if(is_id_declared(&store, $2)) {debug();
        errorDef(yylineno, $2->id);
        exit(1);
    }
    $2->type = $1;
    if(!is_type_compatible($2, $4)) {debug();
        errorMismatch(yylineno);
        exit(1);
    }
    if(has_value($4)) {debug();
        $2->value = $4->value;
    }
    insert_id(&store, $2);
    auto ass = new _T_Assignment($1, $2, $4);
    $$ = ass;

}
| id ASSIGN exp SC
{debug();
    if(!is_id_declared(&store, $1)) {debug();
        errorUndef(yylineno, $1->id);
        exit(1);
    }
    _T_Id* id = get_id(&store, $1);
    if(id == nullptr) {debug();
        errorUndef(yylineno, id->id);
    }
    if(!is_type_compatible(id, $3)) {debug();
        errorMismatch(yylineno);
        exit(1);
    }
    $1->type = $3->type;
    $1->value = $3->value;
    auto lateAss = new _T_LateAssignment($1, $3);
    $$ = lateAss;

}
| call SC
{debug();
    auto call = new _T_Call($1);
    if(!is_call_correct(&store, call, yylineno)) {debug();
        exit(1);
    }
    $$ = call;
}
| RETURN SC
{debug();
    if(store.get_current_func_ret_type() != _T_Type::_VOID_) {debug();
        errorMismatch(yylineno);
        exit(1);
    }
    auto ret = new _T_Return();
    $$ = ret;
}
| RETURN exp SC
{debug();
    if(!is_castable($2->type->typeCase, store.get_current_func_ret_type())) {debug();
        errorMismatch(yylineno);
        exit(1);
    }
    auto ret = new _T_Return($2);
    $$ = ret;
}
| if_pattern
| while LPAREN bool_exp RPAREN statement
{debug();
    end_while(&store);
    $$ = new _T_While($3, $5);
}
| BREAK SC
{debug();
    if(!store.get_in_while()) {debug();
        errorUnexpectedBreak(yylineno);
        exit(1);
    }
    $$ = new _T_Break();
}
| CONTINUE SC
{debug();
    if(!store.get_in_while()) {debug();
        errorUnexpectedContinue(yylineno);
        exit(1);
    }
    $$ = new _T_Continue();
}
;

while:
WHILE
{debug(); begin_while(&store); }
;

if_pattern:
if LPAREN bool_exp RPAREN statement
{debug(); $$ = new _T_If_pattern($3, $5); }
| if LPAREN bool_exp RPAREN statement else statement
{debug(); $$ = new _T_If_pattern($3, $5, $7); }
;

if:
IF
{debug(); begin_if(&store); }
;

else:
ELSE
{debug(); begin_else(&store); }
;

bool_exp:
exp
{debug();
    if(!validations::is_bool($1)) {debug();
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = $1;
}
;

call:
id LPAREN expList RPAREN
{debug();
    if(!is_func_declared(&store, $1)) {debug();
        errorUndefFunc(yylineno, $1->id);
        exit(1);
    }
    auto id = get_func(&store, $1);
    $$ = new _T_CallExp(id, $3);
}
| id LPAREN RPAREN
{debug();
    if(!is_func_declared(&store, $1)) {debug();
        errorUndefFunc(yylineno, $1->id);
        exit(1);
    }
    auto id = get_func(&store, $1);
    $$ = new _T_CallExp(id);
}
;

expList:
exp
{debug(); $$ = new _T_ExpList($1); }
| exp COMMA expList
{debug();
    $3->exp_list.insert($3->exp_list.begin(), $1);
    $$ = $3;
}
;

type:
int
{debug(); $$ = $1; }
| byte
{debug(); $$ = $1; }
| bool
{debug(); $$ = $1; }
;

exp:
LPAREN exp RPAREN
{debug(); $$ = $2; }
| exp IF LPAREN bool_exp RPAREN ELSE exp
{debug();
    if(!is_type_compatible($1, $7)) {debug();
        errorMismatch(yylineno);
        exit(1);
    }
    auto tri = new _T_Trinari($1, $4, $7);
    $$ = tri;
}
| binop
{debug();
 $$ = $1;  }
| id
{debug();
    if(!is_id_declared(&store, $1)) {debug();
        errorUndef(yylineno, $1->id);
        exit(1);
    }
    $$ = get_id(&store, $1);
}
| call
{debug();
    _T_Call call($1);
    if(!is_call_correct(&store, &call, yylineno)) {debug();
        exit(1);
    }
    $$ = $1;
}
| number
{debug(); $$ = new _T_Int($1->value); }
| number B
{debug();
    auto byte = new _T_Byte($1->value);
    if(is_byte_to_large(byte)) {debug();
        errorByteTooLarge(yylineno, to_string(*byte->value));
        exit(1);
    }
    $$ = byte;
}
| string
{debug(); $$ = $1; }
| true
{debug();
$$ = $1; }
| false
{debug(); $$ = $1; }
| NOT exp
{debug();
    auto nott = new _T_Not($2);
    if(!is_type_compatible(nott, $2)) {debug();
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = nott;

}
| exp AND exp
{debug();
    if(!is_bool($1) && !is_bool($3)) {debug();
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = new _T_And($1, $3);
}
| exp OR exp
{debug();
    if(!is_bool($1) && !is_bool($3)) {debug();
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = new _T_Or($1, $3);
}
| exp NE exp
{debug();
    auto relop = new _T_Relop($1, $3, RelopCase::_NE_);
    if(!relop->is_legal(yylineno)) {debug();
        exit(1);
    }
    $$ = relop;
}
| exp EQ exp
{debug();
    auto relop = new _T_Relop($1, $3, RelopCase::_EQ_);
    if(!relop->is_legal(yylineno)) {debug();
        exit(1);
    }
    $$ = relop;
}
| exp LT exp
{debug();
    auto relop = new _T_Relop($1, $3, RelopCase::_LT_);
    if(!relop->is_legal(yylineno)) {debug();
        exit(1);
    }
    $$ = relop;
}
| exp LE exp
{debug();
    auto relop = new _T_Relop($1, $3, RelopCase::_LE_);
    if(!relop->is_legal(yylineno)) {debug();
        exit(1);
    }
    $$ = relop;
}
| exp GT exp
{debug();
    auto relop = new _T_Relop($1, $3, RelopCase::_GT_);
    if(!relop->is_legal(yylineno)) {debug();
        exit(1);
    }
    $$ = relop;
}
| exp GE exp
{debug();
    auto relop = new _T_Relop($1, $3, RelopCase::_GE_);
    if(!relop->is_legal(yylineno)) {debug();
        exit(1);
    }
    $$ = relop;
}
| LPAREN type RPAREN exp
{debug();debug();
    auto cast = new _T_Cast($2, $4);
    if(!is_castable($2->typeCase, $4->type->typeCase, true)) {debug();
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = cast;
}
;

binop:
exp DIV exp
{debug();
    auto binop = new _T_Binop($1, $3, _T_Binop::_DIV_);
    if(!binop->is_legal(yylineno)) {debug();
        exit(1);
    }
    $$ = binop;
}
|exp MULT exp
{debug();
    auto binop = new _T_Binop($1, $3, _T_Binop::_MULT_);
    if(!binop->is_legal(yylineno)) {debug();
        exit(1);
    }
    $$ = binop;
}
|exp SUB exp
{debug();
    auto binop = new _T_Binop($1, $3, _T_Binop::_MINUS_);
    if(!binop->is_legal(yylineno)) {debug();
        exit(1);
    }
    $$ = binop;
}
|exp ADD exp
{debug();
    auto binop = new _T_Binop($1, $3, _T_Binop::_PLUS_);
    if(!binop->is_legal(yylineno)) {debug();
        exit(1);
    }
    $$ = binop;
}
;

number:
NUM
{debug(); $$ = new _T_Int(new int(stoi(yytext))); }
;

id:
ID
{debug();
    auto id = store.get_id(yytext);
    if(id != nullptr) {debug();
        $$ = id;
    } else {debug();
        auto id = store.get_func(yytext);
        if(id != nullptr) {debug();
            $$ = id;
        } else {debug();
            $$ = new _T_Id(string(yytext), nullptr);
        }
    }
}
;

string:
STRING
{debug(); $$ = new _T_String(string(yytext)); }
;

void:
VOID
{debug(); $$ = new _T_Type(_T_Type::_VOID_); }
;

int:
INT
{debug(); $$ = new _T_Type(_T_Type::_INT_); }
;

byte:
BYTE
{debug(); $$ = new _T_Type(_T_Type::_BYTE_); }
;

bool:
BOOL
{debug(); $$ = new _T_Type(_T_Type::_BOOL_); }
;

false:
FALSE
{debug(); $$ = new _T_Bool(false); }
;

true:
TRUE
{debug(); $$ = new _T_Bool(true); }
;




rbrace:
RBRACE
{debug(); end_scope(&store); }
;

lbrace:
LBRACE
{debug(); begin_scope(&store); }
;



epsilon:
;
%%
int main() {
    start_program(&store);
    yyparse();
    end_program(&store);
}
