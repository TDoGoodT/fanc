%{
    #include <string>
    #include "types.hpp"
    #include "hw3_output.hpp"
    #include "symbol_table_manager.hpp"
    #include "actions.hpp"
    #include "validations.hpp"
    using namespace output;
    using namespace actions;
    using namespace validations;
    extern int yyerror(const char *s);
    _T_Type::Type current_func_ret_type;
    bool in_if;
    bool in_else;
    bool in_while;
    SymbolTableManager symbol_table_manager;
    Store store(&symbol_table_manager);
%}
%union {
struct _T_Exp*              T_Exp;
struct _T_Number*           T_Number;
struct _T_Declaration*      T_Declaration;
struct _T_Assignment*       T_Assignment;
struct _T_LateAssignment*   T_LateAssignment;
struct _T_FunctionCall*     T_FunctionCall;
struct _T_Return*           T_Return;
struct _T_If_pattern*       T_If_pattern;
struct _T_While*            T_While;
struct _T_Statements*       T_Statements;
struct _T_Statement*        T_Statement;
struct _T_Not*              T_Not;
struct _T_Assign*           T_Assign;
struct _T_If*               T_If;
struct _T_Else*             T_Else;
struct _T_Id*               T_Id;
struct _T_String*           T_String;
struct _T_Cast*             T_Cast;
struct _T_Void*             T_Void;
struct _T_Bool*             T_Bool;
struct _T_RetType*          T_RetType;
struct _T_Program*          T_Program;
struct _T_Funcs*            T_Funcs;
struct _T_FuncDecl*         T_FuncDecl;
struct _T_Formals*          T_Formals;
struct _T_FormalsList*      T_FormalsList;
struct _T_FormalDecl*       T_FormalDecl;
struct _T_ExpList*          T_ExpList;
struct _T_Type*             T_Type;
struct _T_Binop*            T_Binop;
struct _T_Trinari*          T_Trinari;
struct _T_Call*             T_Call;
struct _T_CallExp*          T_CallExp;
}
%left OR
%left AND
%left RELOP
%left ADD
%left SUB
%left MULT
%left DIV
%left NOT
%left RPAREN
%left LPAREN
%left LBRACE
%left RBRACE
%right ASSIGN
%right IF
%right ELSE
%token RETURN
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token B
%token NUM
%token ID
%token STRING
%token VOID
%token INT
%token BYTE
%token BOOL
%token FALSE
%token TRUE
%type <T_Type> void
%type <T_Type> int
%type <T_Type> byte
%type <T_Type> bool
%type <T_Bool> false
%type <T_Bool> true
%type <T_String> string
%type <T_Id> id
%type <T_Id> fid
%type <T_Program> program
%type <T_Funcs> funcs
%type <T_FuncDecl> funcDecl
%type <T_RetType> retType
%type <T_Formals> formals
%type <T_FormalsList> formalsList
%type <T_FormalDecl> formalDecl
%type <T_Statements> statements
%type <T_Statement> statement
%type <T_Statement> if_pattern
%type <T_ExpList> expList
%type <T_Type> type
%type <T_Exp> exp
%type <T_Exp> bool_exp
%type <T_Number> number
%type <T_Binop> binop
%type <T_CallExp> call
%%
program:
funcs
{ $$ = new _T_Program($1); }
;

funcs:
epsilon
{ $$ = new _T_Funcs(); }
| funcDecl funcs
{
    $2->func_list.push_back($1);
    $$ = $2;
}
;

funcDecl:
retType fid LPAREN formals RPAREN LBRACE statements RBRACE
{
    $2->type = $1->type;
    auto func = new _T_FuncDecl($2, $4, $7);
    end_function(&store, func);
    $$ = func;
}
;

fid:
id
{
    if(is_func_declared(&store, $1)) {
        errorDef(yylineno, $1->id);
        exit(1);
    }
    declare_func(&store, $1);
    $$ = $1;
}
;

retType:
type
{
    begin_function(&store, $1->typeCase);
    auto ret     = new _T_RetType($1);
    $$ = ret;
}
| void
{
    begin_function(&store, _T_Type::_VOID_);
    $$ = new _T_RetType(_T_Type::_VOID_);;
}
;
formals:
epsilon
{ $$ =  new _T_Formals(); }
| formalsList
{
    insert_function_params(&store, $1);
    $$ = new _T_Formals($1);
}
;
formalsList:
formalDecl
{ $$ =  new _T_FormalsList($1); }
| formalDecl COMMA formalsList
{
    if(is_formal_declared($3->formal_list, $1->id)){
        errorDef(yylineno, $1->id->id);
        exit(1);
    }
    $3->formal_list.insert($3->formal_list.begin(), $1);
    $$ = $3;
}
;

formalDecl:
type id
{
    if(is_id_declared(&store, $2)) {
        errorDef(yylineno, $2->id);
        exit(1);
    }
    $2->type = $1;
    $$ = new _T_FormalDecl($2);
}
;

statements:
statement
{
    auto stmnts = new _T_Statements($1);
    $$ = stmnts;
}
| statements statement
{
    $1->statement_list.push_back($2);
    $$ = $1;
}
;

statement:
lbrace statements rbrace
{ $$ = $2; }
| type id SC
{
    if(is_id_declared(&store, $2)) {
        errorDef(yylineno, $2->id);
        exit(1);
    }
    $2->type = $1;
    insert_id(&store, $2);
    auto decl = new _T_Declaration($1, $2);
    $$ = decl;
}
| type id ASSIGN exp SC
{
    if(is_id_declared(&store, $2)) {
        errorDef(yylineno, $2->id);
        exit(1);
    }
    $2->type = $1;
    if(!is_type_compatible($2, $4)) {
        errorMismatch(yylineno);
        exit(1);
    }
    if(has_value($4)) {
        $2->value = $4->value;
    }
    insert_id(&store, $2);
    auto ass = new _T_Assignment($1, $2, $4);
    $$ = ass;
}
| id ASSIGN exp SC
{
    if(!is_id_declared(&store, $1)) {
        errorUndef(yylineno, $1->id);
        exit(1);
    }
    _T_Id* id = get_id(&store, $1);
    if(id == nullptr) {
        errorUndef(yylineno, id->id);
    }
    if(!is_type_compatible(id, $3)) {
        errorMismatch(yylineno);
        exit(1);
    }
    $1->type = $3->type;
    $1->value = $3->value;
    auto lateAss = new _T_LateAssignment($1, $3);
    $$ = lateAss;
}
| call SC
{
    auto call = new _T_Call($1);
    if(!is_call_correct(&store, call, yylineno)) {
        exit(1);
    }
    $$ = call;
}
| RETURN SC
{
    if(store.get_current_func_ret_type() != _T_Type::_VOID_) {
        errorMismatch(yylineno);
        exit(1);
    }
    auto ret = new _T_Return();
    $$ = ret;
}
| RETURN exp SC
{
    if(!is_castable($2->type->typeCase, store.get_current_func_ret_type())) {
        errorMismatch(yylineno);
        exit(1);
    }
    auto ret = new _T_Return($2);
    $$ = ret;
}
| if_pattern
| while LPAREN bool_exp RPAREN statement
{
    end_while(&store);
    $$ = new _T_While($3, $5);
}
| BREAK SC
{
    if(!store.get_in_while()) {
        errorUnexpectedBreak(yylineno);
        exit(1);
    }
    $$ = new _T_Break();
}
| CONTINUE SC
{
    if(!store.get_in_while()) {
        errorUnexpectedContinue(yylineno);
        exit(1);
    }
    $$ = new _T_Continue();
}
;

while:
WHILE
{ begin_while(&store); }
;

if_pattern:
if LPAREN bool_exp RPAREN statement
{ $$ = new _T_If_pattern($3, $5); }
| if LPAREN bool_exp RPAREN statement else statement
{ $$ = new _T_If_pattern($3, $5, $7); }
;

if:
IF
{ begin_if(&store); }
;

else:
ELSE
{ begin_else(&store); }
;

bool_exp:
exp
{
    if(!validations::is_bool($1)) {
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = $1;
}
;

call:
id LPAREN expList RPAREN
{
    if(!is_func_declared(&store, $1)) {
        errorUndefFunc(yylineno, $1->id);
        exit(1);
    }
    auto id = get_func(&store, $1);
    $$ = new _T_CallExp(id, $3);
}
| id LPAREN RPAREN
{
    if(!is_func_declared(&store, $1)) {
        errorUndefFunc(yylineno, $1->id);
        exit(1);
    }
    auto id = get_func(&store, $1);
    $$ = new _T_CallExp(id);
}
;

expList:
exp
{ $$ = new _T_ExpList($1); }
| exp COMMA expList
{
    $3->exp_list.insert($3->exp_list.begin(), $1);
    $$ = $3;
}
;

type:
int
{ $$ = $1; }
| byte
{ $$ = $1; }
| bool
{ $$ = $1; }
;

exp:
LPAREN exp RPAREN
{ $$ = $2; }
| exp IF LPAREN bool_exp RPAREN ELSE exp
{
    if(!is_type_compatible($1, $7)) {
        errorMismatch(yylineno);
        exit(1);
    }
    auto tri = new _T_Trinari($1, $4, $7);
    $$ = tri;
}
| binop
{ $$ = $1; }
| id
{
    if(!is_id_declared(&store, $1)) {
        errorUndef(yylineno, $1->id);
        exit(1);
    }
    $$ = get_id(&store, $1);
}
| call
{
    _T_Call call($1);
    if(!is_call_correct(&store, &call, yylineno)) {
        exit(1);
    }
    $$ = $1;
}
| number
{ $$ = new _T_Int($1->value); }
| number B
{
    auto byte = new _T_Byte($1->value);
    if(is_byte_to_large(byte)) {
        errorByteTooLarge(yylineno, to_string(*byte->value));
        exit(1);
    }
    $$ = byte;
}
| string
{ $$ = $1; }
| true
{ $$ = $1; }
| false
{ $$ = $1; }
| NOT exp
{
    auto nott = new _T_Not($2);
    if(!is_type_compatible(nott, $2)) {
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = nott;
}
| exp AND exp
{
    if(!is_bool($1) && !is_bool($3)) {
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = new _T_And($1, $3);
}
| exp OR exp
{
    if(!is_bool($1) && !is_bool($3)) {
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = new _T_Or($1, $3);
}
| exp RELOP exp
{
    auto relop = new _T_Relop($1, $3);
    if(!relop->is_legal(yylineno)) {
        exit(1);
    }
    $$ = relop;
}
| LPAREN type RPAREN exp
{
    auto cast = new _T_Cast($2, $4);
    if(!is_castable($2->typeCase, $4->type->typeCase, true)) {
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = cast;
}
;

binop:
exp DIV exp
{
    auto binop = new _T_Binop($1, $3);
    if(!binop->is_legal(yylineno)) {
        exit(1);
    }
    $$ = binop;
}
|exp MULT exp
{
    auto binop = new _T_Binop($1, $3);
    if(!binop->is_legal(yylineno)) {
        exit(1);
    }
    $$ = binop;
}
|exp SUB exp
{
    auto binop = new _T_Binop($1, $3);
    if(!binop->is_legal(yylineno)) {
        exit(1);
    }
    $$ = binop;
}
|exp ADD exp
{
    auto binop = new _T_Binop($1, $3);
    if(!binop->is_legal(yylineno)) {
        exit(1);
    }
    $$ = binop;
}
;

number:
NUM
{ $$ = new _T_Int(new int(stoi(yytext))); }
;

id:
ID
{
    auto id = store.get_id(yytext);
    if(id != nullptr) {
        $$ = id;
    } else {
        auto id = store.get_func(yytext);
        if(id != nullptr) {
            $$ = id;
        } else {
            $$ = new _T_Id(string(yytext), nullptr);
        }
    }
}
;

string:
STRING
{ $$ = new _T_String(string(yytext)); }
;

void:
VOID
{ $$ = new _T_Type(_T_Type::_VOID_); }
;

int:
INT
{ $$ = new _T_Type(_T_Type::_INT_); }
;

byte:
BYTE
{ $$ = new _T_Type(_T_Type::_BYTE_); }
;

bool:
BOOL
{ $$ = new _T_Type(_T_Type::_BOOL_); }
;

false:
FALSE
{ $$ = new _T_Bool(false); }
;

true:
TRUE
{ $$ = new _T_Bool(true); }
;




rbrace:
RBRACE
{ end_scope(&store); }
;

lbrace:
LBRACE
{ begin_scope(&store); }
;



epsilon:
;
%% 
int main() {
    start_program(&store);
    yyparse();
    end_program(&store);
}
